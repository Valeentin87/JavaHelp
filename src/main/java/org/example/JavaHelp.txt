
^^1.|*---JAVA---|*Название подраздела|*Формулировка вопроса|*Ответ на сформулированный вопрос^^
----------
^^1.
|*---JAVA---|*Знакомство с Java|*Назовите основные достоинства языка Java|*
1. кроссплатформерность
2. множество вакансий
3. Разработка под Android
4. Много бэкэнда на Jave
5. Безопасность
6. ООП
7. Многопоточность^^
----------
^^2.
|*---JAVA---|*Установка JDK|*Как установить Java для работы с VSC|*
Устанавливаем JDK https://www.oracle.com/java/technologies/downloads
Подгружаем в VSC необходимый для работы с JAVA пакет
Создаём новый проект, в котором создаём файл programm.java^^
----------
^^3.
|*---JAVA---|*Знакомство с Java|*Что является минимальной единицей работы в Java|*
Минимальная единица работы в jave это класс, поэтому набираем class и из автоматического поиска добавляем новый класс у него название будет как и название программы
далее определяем точку входа в программы - метод main(). Набираем main и автоматически всталяем в код:
public static void main(String[] args) {

    }
^^
----------
^^4.
|*---JAVA---|*Знакомство с Java|*Что необходимо набрать, чтобы что-то вывести в консоль|*
Чтобы что-то напечатать в консоль необходимо набрать System.out.println("bye world");
при этом достаточно знать снипы (сокращения) здесь сокращение sout
^^
----------
^^5.
|*---JAVA---|*Знакомство с Java|*Как запустить программу на выполнение|*
Чтобы запустить программу нажимаем треугольник в правом верхнем углу.
Второй вариант открыть в интегрированном терминале и набрать команду java programm.java
^^|*---JAVA---|*Синтаксис Java|*Как в java обозначаются однострочные комментарии|*
//текст комментария
^^
----------
^^6.
|*---JAVA---|*Синтаксис Java|*Как в java обозначаются многострочные комментарии|*
/* начало комментария
продолжение комментария
окончание комментария
*/
^^
----------
^^7.
|*---JAVA---|*Данные и их типы|*Какие типы данных в java Вы знаете|*
Типы данных (бывают ссылочные (классы, массивы....) и примитивные(int, short, long, / float, double, / boolean, / char))
^^
----------
^^8.
|*---JAVA---|*Данные и их типы|*Что значит инициализировать и идентифицировать переменную в Java|*
Идентификация и инициализация переменных:
int a; // инициализация переменной
String s = "   dfggh"; //идентификация переменной
float r = 2.7f;     // вещественная переменная c обязательным указанием f
double pi = 3.1415; // вещественная переменная с не обязательным указанием D  3.1415D будет эквивалентно
char p = '}'  // символьный тип данных
boolean f = true & false; // логический тип данных
^^
----------
^^9.
|*---JAVA---|*Данные и их типы|*Что значит тип даных var, что такое неявная типизация данных|*
НЕЯВНАЯ ТИПИЗАЦИЯ
var i = 123;   // переменной будет присвоен тип, который больше всего подходит значению
^^
----------
^^10.
|*---JAVA---|*Данные и их типы|*как определить тип данных любого объекта с помощью метода getType()|*
Определение типа переменной методом getType()
    необходимо сначала прописать отдельный класс, позволяющий определять тип переменной
    static String getType(Object o){
        return o.getClass().getSimpleName();
    }
^^
----------
^^11.
|*---JAVA---|*Данные и их типы|*Что такое классы-обертки и для чего они применяются|*
Классы обертки
    int     Integer
    string  String
    float   Float
    double  Double
    short   Short
    long    Long
    byte    Byte
    char    Character
    boolean Boolean

    Классы-обёртки нужны для того, чтобы получить какие либо развёрнутые данные в отношении переменных соответствующих типов
    например:
    int p = 6788;
    System.out.println(Integer.MAXVALUE);
^^
----------
^^12.
|*---JAVA---|*Операции над данными|*Какие виды операций над данными в языке Java Вы знаете|*
Операции:
    Присванивание: =
    Арифметические: +,-,*,/,%,++,--
    Операции сравнения: ==,>=,<=,!=
    Логические операции: &&, ||, ^, !
    Побитовые операции: &, |, ^, <<, >>

    Приоритет вывода в терминал(консоль) выше, чем приоритет инкремента (декремента)

    boolean x = 123>234; // в консоли должно выдать false

    || - коньюнкция
    && - дизъюнкция
    ! - инверсия
    ^ - разделительная дизъюнкция
^^
----------
^^13.
|*---JAVA---|*Операции над данными|*Что такое побитовые операции, их смысл и примеры|*
// побитовые операции------------------------
    int c = 5;
    int d = 7;
    System.out.println(c | d); // числа представляются в двоичной записи и каждый разряд побитово применяет логическое или, далле перевод в десятичное представление
    System.out.println(c & d); // тоже самое, только применяется побитовое 'И'
    System.out.println(c ^ d); // тоже самое, только применяется разделительное "И" (истина тогда, когда строго одно истина)
// более сложный случай --------------
    // коньюнкция && истина будет тогда, когда истина оба выражения и если хотя бы одно ложь, то результат ложь
    // дизъюнкция || истина будет тогда, когда истина хотя бы одно выражение
    String message = "34fj700";
    boolean h = message.length() >= 10 && message.charAt(3) == 'j';
    h = message.length() >= 10 || message.charAt(3) == 'j';
    System.out.println(h);
^^
----------
^^14.
|*---JAVA---|*Массивы|*Как объявляется новый массив данных в Java|*
Массив представляет собой совокупность однотипных переменных с общим именем.
тип имя_массива [] = new тип[размер]
int[] arr = new int[10]; // классическое объявление массива, по умолчанию все элементы равны 0//память для массива выделяеься динамически с помощью оператора new
    String[] crr = new String[10]; // по умолчанию все элементы равны null
    char[] drr = new char[10]; // по умолчанию все элементы равны ' '
    int brr[] // такое объявление массива тоже возможно
    boolean[] frr = new boolean[10]; // по умолчанию все элементы равны false
^^
----------
^^15.
|*---JAVA---|*Массивы|*Как узнать длину(размер) массива и вывести его в консоль|*
arr.length; //длина массива
System.out.println(arr.length); // вывод в консоль длины массива
^^
----------
^^|*---JAVA---|*Массивы|*Как объявить массив и сразуего наполнить данными при объявлении|*
int[] brr = new int[] {1, 2, 3, 4}; // вариант задания массива c идентификацией
String[] name ={"Олег","Антон","Пётр"};
^^
----------
^^16.
|*---JAVA---|*Массивы|*Как обратиться к элменту массива по индексу|*
System.out.println(brr[2]); // обращение, в данном случае вывод в консоль элемента массива по второму индексу
^^
----------
^^17.
|*---JAVA---|*Массивы|*Как присвоить элементу массива значение|*
arr[2] = 5;//присванивание значения в массиве по какому-то индексу
^^
----------
^^18.
|*---JAVA---|*Двумерные массивы|*Как объявить двумерный массив|*
int[] vrr[] = new int[3][5]; // объявление двумерного массива с 3 строками и 5 столбцами
^^
----------
^^19.
|*---JAVA---|*Двумерные массивы|*Как объявить массив массивов|*
int[][] mrr; //объявление массива массивов(несколько отличается от двумерного)
^^
----------
^^20.
|*---JAVA---|*Двумерные массивы|*Как вывести в консоль двухмерный массив|*
// распечатывание массива массивов
    int[][] arr = new int[3][5];

        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.printf("%d ", arr[i][j]);
            }
^^
----------
^^21.
|*---JAVA---|*Данные и их типы|*Как можно проводить преобразования данных одного типа в другой|*
// преобразования
    int i = 123; double d = i; // неявное преобразование int в double
    System.out.println(i);  // 123
    System.out.println(d);  // 123.0
    d = 3.1415; i = (int)d; // явное преобразование к типу int
    System.out.println(d);  // 3.1415
    System.out.println(i);  // 3
    d = 3.9415; i = (int)d;
    System.out.println(d);  // 3.9415
    System.out.println(i);  // 3
    byte b = Byte.parseByte("123"); // явное преобразование к типу byte, используя класс-обёртку Byte.
    System.out.println(b);  // 123
    b = Byte.parseByte("1234");
    System.out.println(b);  // NumberFormatException: Value out of range
    // в двух строчках ниже отображено, что в массив с типом double нельзя положить массив типа int
    int[] a = new int[10];
    double[] d = a;   // ИЗУЧАЕМ ковариантность и контравариантность
^^
----------
^^22.
|*---JAVA---|*Обработка данных|*Как можно получить данные из терминала с помощью класса Scanner|*
//получение данных из терминала
import java.util.Scanner; //сначала импортируем java.util.Scanner
public class programm {
   public static void main(String[] args) {
       Scanner iScanner = new Scanner(System.in); //создаём экземпляр класса Scanner и в качестве аргумента указываем System.in, откуда будем забирать данные
       System.out.printf("name: "); //можем выводить на экран (только вместо println используем printf )
       String name = iScanner.nextLine(); // определяем тип вводимых данных и название переменной, в кот с помощью метода nextLine, применяемого к нашему экземпляру класса Scanner ожидаем ввод строки
       System.out.printf("Привет, %s!", name);
       iScanner.close(); // закрываем наш объект
   }
}
^^
----------
^^23.
|*---JAVA---|*Обработка данных|*Как использовать форматированный вывод в консоль|*
System.out.printf("name: "); //можем выводить на экран (только вместо println используем printf )
System.out.printf("Привет, %s!", name);
^^
----------
^^24.
|*---JAVA---|*Обработка данных|*Как получить из терминала данные типа int и double с помощью класса Scanner|*
// ввод в консоль типа int, типа double
import java.util.Scanner;
public class programm {
    public static void main(String[] args) {
        Scanner iScanner = new Scanner(System.in);
        System.out.printf("int a: "); // печатаем себе подсказку в консоль, что ожидаем ввода целых чисел
        int x = iScanner.nextInt(); // определяем переменную типа int, в которую методом nextInt будем вводить данные
        System.out.printf("double a: "); // печатаем себе подсказку в консоль, что ожидаем ввода  чисел типа double
        double y = iScanner.nextDouble(); // определяем переменную типа double, в которую методом nextDouble будем вводить данные
        System.out.printf("%d + %f = %f", x, y, x + y);
        iScanner.close();
}}
^^
----------
^^25.
|*---JAVA---|*Обработка данных|*Как проверить данные на соответствие вводимого типа в классе Scanner|*
// проверка вводимых данных на соответствие вводимого типа
import java.util.Scanner;
public class programm {
   public static void main(String[] args) {
       Scanner iScanner = new Scanner(System.in);
       System.out.printf("int a: ");
       boolean flag = iScanner.hasNextInt(); //позволяет проверить истинно или ложно, что введенные данные типа int
       System.out.println(flag); // выводит в консоль или true или false
       int i = iScanner.nextInt(); // кладёт в переменную i  данные которые мы вводили для проверки соответствия типу
       System.out.println(i);
       iScanner.close();
   } }
^^
----------
^^26.
|*---JAVA---|*Работа со строками|*Покажите пример конкатенации строк и в чем её недостаток|*
public class programm {
    public static void main(String[] args) {
    int a = 5;
    String b = "qwer";
    String c = a + b;
    System.out.println(c);

    }
}

В том случае, если складываются переменные типов, отличных от int, то они автоматически динамически приводятся к типу стринг
^^
----------
^^27.
|*---JAVA---|*Работа со строками|*Как использовать форматированный вывод строки|*
public class programm {
    public static void main(String[] args) {
        int a = 1, b = 2;
        int c = a + b;
        String res = String.format("%d + %d = %d \n", a, b, c); //если форматированную строку придется дальше сипользовать то применяют метод String.format
        System.out.printf("%d + %d = %d \n", a, b, c); //если форматированную строку только выводят в консоль, то применяют обычный синтаксис
        System.out.println(res);
    }
}
// виды спецификаторов
%d: целочисленных значений
%x: для вывода шестнадцатеричных чисел
%f: для вывода чисел с плавающей точкой
%e: для вывода чисел в экспоненциальной форме,
например, 3.1415e+01
%c: для вывода одиночного символа
%s: для вывода строковых значений
^^
----------
^^28.
|*---JAVA---|*Область видимости переменных|*Что такое в крупную клетку область видимости переменных|*
Область видимости переменных
У переменных существует понятие «область видимости».
Если переменную объявили внутри некоторого блока фигурных скобок { },
то снаружи этого блока переменная будет недоступна.
1.Переменная объявленная в классе, видна во всех методах.
2. Переменная, объявленная в методе, видна только внутри метода, снаружи нет.
3. Нельзя инициализировать переменную с одним именем два раза, в том числе в разных блоках

public class Program {
   public static void main(String[] args) {
       {
           int i = 123;
           System.out.println(i);
       }
       System.out.println(i);  // error: cannot find symbol
   }
}
^^
----------
^^29.
|*---JAVA---|*Функицональный подход в программировании|*Приведите простейшие примеры методов в Java (как возвращающих значения, так и нет)|*
Функции и методы

public class Program {
    static void sayHi() {
        System.out.println("hi!");
    }
    static int sum(int a, int b) {
        return a+b;
    }
    static double factor(int n) {
        if(n==1)return 1;
        return n * factor(n-1);
    }
    public static void main(String[] args) {
        sayHi(); // hi!
        System.out.println(sum(1, 3)); // 4
        System.out.println(factor(5)); // 120.0
^^
----------
^^30.
|*---JAVA---|*Операторы ветвления|*Опишите общий синтаксис условного оператора if|*

Условный оператор if

if (условие) {  // в случае истинности условия выполняется последовательность операторов
последовательность операторов
}
else { // в случае ложности условий выполняется последовательность, указанная после else
последовательность операторов
}


public class Program {
    public static void main(String[] args) {
        int a = 1;
        int b = 2;
        int c;
        if (a > b) {
            c = a;
        } else {
            c = b;
        }
        System.out.println(c);
    }
}
^^
----------
^^31.
|*---JAVA---|*Операторы ветвления|*Опишите общий синтаксис условного оператора if если тело условия предполагает один оператор|*
если операции после условия в одну строку то можно без скобок
public class Program {
    public static void main(String[] args) {
        int a = 1;
        int b = 2;
        int c = 0;
        if (a > b) c = a;
        if (b > a) c = b;

        System.out.println(c);
    }
^^
----------
^^32.
|*---JAVA---|*Операторы ветвления|*Опишите синтаксис тернарного оператора ветвления|*
тернарный оператор
public class Program {
    public static void main(String[] args) {
        int a = 1;
        int b = 2;
        int min = a < b ? a : b; //если выполняется условие, то возвращается значение a, если нет возвращается значение b
        System.out.println(min);
^^
----------
^^33.
|*---JAVA---|*Операторы выбора|*Опишите общий синтаксис конструкции switch - case|*
-------оператор выбора switch - case---------------
switсh(выражение) {      // оператор сравнивает значение выражение одной из констант, при этом выполняется соответствуюшая
    case константа 1:    // последовательность операторов, оператор break позволяет выйти из конструкции switch-case
        последовательность операторов  // если не указано слова break, то продолжается выполнение последовательности
        break;          // операторов из других блоков case
    case константа 2:
        последовательность операторов
        break;
    case константа 3:
        последовательность операторов
        break;
    default:
        последовательность операторов
    }
// если необходимо выполнить одну и ту же последовательность действий для разных значений констант, то применяют следующую конструкцию

switch(выражение) {
    case константа 1:
    case константа 2:
    case константа 3:
        последовательность операторов
        break;
}



import java.util.Scanner;
public class Program {
    public static void main(String[] args) {
        int mounth = value;
        String text = "";
        switch (mounth) {  // в зависимости рот того, какое значение будет принимать переменная mounth (значения указаны
        //после слов case, при этом каждый блок case должен заканчиваться конструкцией break
            case 1:
                text = "Autumn";
                break;
		...
            default:   // необязательный блок, который описывает порядок действий в том случае, если переменная не
            // приняла ни одно из значений
                text = "mistake";
                break;
        }
        System.out.println(text);
        iScanner.close();
    }
}
^^
----------
^^34.
|*---JAVA---|*Операторы выбора|*Опишите общий синтаксис конструкции switch - case для случая, когда нескольким значениям предусмотрен один порядок действий|*
switch (name) {
    case 1:
    case 2:
    case 'Mark':
    case 0,567:
        name = name+2;
        break

}
^^
----------
^^35.
|*---JAVA---|*Циклы|*Как вы понимаете себе циклы. Какие виды циклических операторов предусмотрены в языке Java|*
Циклы.

Цикл — это многократное выполнение одинаковой последовательности действий.

В java доступны следующие циклы:
цикл while;
цикл do while;
цикл for; и его модификация for in
^^
----------
^^36.
|*---JAVA---|*Циклы|*Опишите общий синтаксис цикла while|*
------------цикл while----------------
while (условие) {     // выполняется до тех пор, пока истинно условие
    последовательность действий;
}

public class Program {
    public static void main(String[] args) {
        int value = 321;
        int count = 0;

        while (value != 0) {
            value /= 10;
            count++;
        }
        System.out.println(count);
    }
}
^^
----------
^^37.
|*---JAVA---|*Циклы|*Опишите общий синтаксис цикла do while|*
-----------цикл с постусловием do while---------------
сначала выполняется тело цикла, а после этого уже проверяется условие.
do {            // тело цикла выполняется хотя бы один раз
блок операций
} while (условие);

public class Program {
    public static void main(String[] args) {
        int value = 321;
        int count = 0;

        do {
            value /= 10;
            count++;
        } while (value != 0);
        System.out.println(count);
    }
}
^^
----------
^^38.
|*---JAVA---|*Циклы|*Опишите принцип работы ключевых слов continue и break|*
continue, break
  Операторы для управления циклами — continue и break.
  Выполнение следующей итерации цикла — continue.
  Прерывание текущей итерации цикла — break.
  * ближайшего к оператору
--------конструкция break-------------
// позволяет выйти досрочно из тела цикла и продолжить выполнение операций, спланированных после цикла
// если операция break спланирована во вложенном цикле, то она позволяет вернуться в тело вышестоящего цикла
// оператор break, находящийся внутри конструкции switch - case распространяется только на эту конструкцию, но не на
цикл, окружающий его
--------конструкция continue----------
С помощью оператора continue можно организовать досрочное завершение шага
итерации цикла в обход обычной структуры управления циклом. Оператор continue
осуществляет принудительный переход к следующему шагу цикла, пропуская
оставшийся не выполненныи код
^^
----------
^^39.
|*---JAVA---|*Циклы|*Опишите общий синтаксис цикла for|*
цикл for ----------------------------
fоr(инициализация; условие; итерация) оператор;
итерация - порядок изменения переменной цикла на каждой итерации
инициализация - инициализация переменной цикла
условие - пока условие цикла истинно цикл продолжает выполняться

public class Program {
    public static void main(String[] args) {

        int s = 0;
        for (int i = 1; i <= 10; i++) {
            s += i;
        }
        System.out.println(s);
    }
}
^^
----------
^^40.
|*---JAVA---|*Циклы|*Приведите пример вложенного цикла, как он работает|*
вложенные циклы ----------------------
public class Program {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 5; j++) {
                System.out.print("* ");
            }
            System.out.println();
        }
        // * * * * *
        // * * * * *
        // * * * * *
        // * * * * *
        // * * * * *
    }
}
^^
----------
^^41.
|*---JAVA---|*Циклы|*Опишите общий синтаксис цикла for in|*
циклы for in --------------------------
public class Program {
    public static void main(String[] args) {

        int arr[] = new int[10];
        for (int item : arr) {  // действия, описанные в теле цикла будут проведены с каждым элементом итерируемой
        // коллекции
            System.out.printf("%d ", item);
        }
        System.out.println();
    }
}
^^
----------
^^42.
|*---JAVA---|*Основные определения|*Как Вы понимаете, что такое аплет|*
Аплет - это особая разновидность программ на Java, предназначенная для передачи
по Интернету и автоматического выполнения в среде, формируемой Jаvа-совместимым
браузером.
^^
----------
^^43.
|*---JAVA---|*Основные определения|*Как Вы понимаете, что такое байт-код и как он используется JVM|*
Добиться безопасности и переносимости программ по сети позволяет генерируемый
байт-кодом. Эго оптимизированный набор команд, предназначенных для выполнения
в исполняющей системе Java, называемой виртуальной машиной Java (Java Virtual Machine -
JVМ).
^^
----------
^^44.
|*---JAVA---|*Основные определения|*Как Вы понимаете, что такое сервлет|*
Сервлет - это небольшая программа, выполняемая на стороне сервера.Динамически реализуют
дополнительные функции веб-сервера
^^
----------
^^45.
|*---JAVA---|*Основны ООП|*Назовите основные принципы ООП на Java|*
Принципы ООП:
- инкапсуляция;
- полиморфизм;
- наследование;
- абстракция;
^^
----------
^^46.
|*---JAVA---|*Основны ООП|*Что Вы понимаете под инкапсуляцией|*
Инкапсуляция представляет собой механизм программирования, объединяющий код
и данные, которыми он манипулирует.
(private) - данные внутри объекта закрыты, напротив - public
^^
----------
^^47.
|*---JAVA---|*Основны ООП|*Что Вы понимаете под классом и под объектом класса|*
Класс - основная языковая конструкция, определяющая инкапсуляцию.
Объекты - экземпляры класса. Класс определяет по каим чертежам будет строится объект.
Внутри класса - переменные-члены и методы-члены (выполняют действия над этими переменными)
^^
----------
^^48.
|*---JAVA---|*Основны ООП|*Что Вы понимаете под полиморфизмом|*
Полиморфизм (от греческого слова, означающего "много форм") - это свойство, позволяющее
с помощью одного интерфейса обращаться к общему классу действий.
Принцип полиморфизма хорошо иллюстрируется следующим выражением: "один
интерфейс - множество методов"
^^
----------
^^49.
|*---JAVA---|*Память|*как работает "стек" в памяти (по какому принципу) и "очередь"|*
Принцип "стека" - "последним поступил - первым обслужен" LIFO - стек (последним пришел - первым обслужись - lastin, first-out), которая извлекает из очереди последнего добавленного в неё.
Принцип "очереди" - "первым зашёл - первым вышел" очереди FIFO (первым пришел -
первым обслужись - first-in, first-out), которая моделирует обслуживание в типичной очереди - каждый новый элемент добавляется в конец очереди, и элементы извлекаются с начала
очереди.
^^
----------
^^50.
|*---JAVA---|*Основны ООП|*Что Вы понимаете под наследованием|*
Наследование - это процесс, в ходе которого один объект приобретает свойства другого объекта.
Благодаря наследованию для объекта достаточно указать те свойства, которые отличают его от других
классов, а остальные общие атрибуты он наследует от своих родительских классов. Таким образом,
благодаря наследованию возможно создать объект, являющийся экземпляром более общего класса
^^
----------
^^51.
|*---JAVA---|*Знакомство с Java|*Какой файл создаётся в Idiea при создании нового проекта являющийся сборщиком|*
При создании нового проекта в Idiea создается файл сборщик pom.xml
^^
----------
^^52.
|*---JAVA---|*Функицональный подход в программировании|*Что определяет метод main в Java|*
В Java обязательно в коде указывать место входа в программу, так нызываемый метод main.
Для этого набираем сокращенно main (либо pvsm) и формируется точка входа в программу
public static void main(String[] args) {
    }
public - модификатор доступа, позволяет обращаться к членам класса за пределами класса, напротив - private
static - допускает вызов метода main до создания объекта класса
void - означает, что метод main ничего не возвращает
String args [] - указывает,что методу main передаются в качестве параметров аргументы, прописываемы в командной строке
при запуске программы
args - имя массива строк String[], к которому можно будет обращаться далее
^^
----------
^^53.
|*---JAVA---|*Данные и их типы|*Дайте характеристику типу char|*
char j = 'h'; // хранит 16 битную информацию о номере символа, а также может хранить числа до 16 бит
char j = 45; // имеет место
char j = -45; // недопустимо
^^
----------
^^54.
|*---JAVA---|*Работа со строками|*Назовите метод класса String, приводящий к строке аргумент|*

String.value0f(......) // приводит к строке аргумент метода
^^
----------
^^55.
|*---JAVA---|*Работа со строками|*Назовите метод класса String, возвращающий символ из строки|*
String msg = "Hello";
char char1 = msg.charAt(3); // возвращает символ строки под номером 3
^^
----------
^^56.
|*---JAVA---|*Работа со строками|*Назовите метод класса String, разбивающий строку на массив символов|*

String msg = "Hello";
msg.split(regex:"разделитель"  // возвращает массив строк
^^
----------
^^57.
|*---JAVA---|*Работа со строками|*Как работает метод repeat класса String|*
"hello".repeat(count: 5)  // вернет строку в которой будет 5 раз hello
^^
----------
^^58.
|*---JAVA---|*Работа со строками|*Как проверить вхождение одной строки в другую|*
String msg = "Hello World";
msg.contains("hello"); // проверка вхождения 'hello' в строку msg , вернет булевое значение
msg.compareTo("Wo")   // ищет в строке указанную строку и выдает индекс ее первого вхождения
^^
----------
^^59.
|*---JAVA---|*Данные и их типы|*Как преобразовать значение к восьмеричному|*
Integer.toOctalString(); // преобразование десятичного к восьмеричному
^^
----------
^^60.
|*---JAVA---|*Данные и их типы|*Как преобразовать значение к шестнадцатеричному|*
Integer.toHexString(); // преобразование десятичного к шестнадцатиричному

^^
----------
^^61.
|*---JAVA---|*Работа со строками|*Как можно и как не стоит стравнивать две строки|*
равнение строк ----- нельзя сравнивать их через знак ==
String strOne = "tgjkrnvkr"
String strTwo = "brjfbr"
if(strOne.equal(strTwo){ // корректное сравнение двух строк
}
^^
----------
^^62.
|*---JAVA---|*Ввод и вывод данных|*Какие варианты вывода в консоль System.out.print... Вы знаете|*
Вывод в консоль
// сокращение sout
System - предопределенный класс, предоставляющий доступ к системным ресурсам
out - поток вывода на консоль
println - метод, позволяющий выводитьв консоль данные определенного типа, указанные в скобках
System.out.println("Hello");   // sout вывод в консоль с переносом строки
System.out.print("Hello");   // sout вывод в консоль без переноса строки
System.out.printf("Hello, %s",name);   // форматированный вывод
System.out.println(); // вывод в консоль пустой строки
^^
----------
^^63.
|*---JAVA---|*Классы|*Опишите как объявляется новый класс в Java|*
Class Example {   // новый класс с именем Example
  // члены класса
}
^^
----------
^^64.
|*---JAVA---|*Знакомство с Java|*Java - регистрозависимый язык, то это значит|*
Java регистрозависимый язык
String apple;
int aPple; // это разные переменные
^^
----------
^^65.
|*---JAVA---|*Данные и их типы|*Как объявить сразу несколько переменных в одном операторе|*
int var1, var2;  // объявление сразу нескольких переменных, обе переменные объявляются в одном операторе
^^
----------
^^66.
|*---JAVA---|*Операции над данными|*Какие операции сравнения применяются в Java|*
Полный набор операций сравнения: >,<,<=,>=,!=,==
^^
----------
^^67.
|*---JAVA---|*Операции над данными|*Что такое операция инкремент и декремент в Java|*
count++; // операция инкремента (увеличивает значение на 1)
count--; // операция декремента (уменьшает значение на 1)
Операция вывода в консоль имеет приоритет над инкрементом(декрементом)
int count = 5;
System.out.print(count++); // будет выведено значение 5
Существует префиксный инкремент и постфиксный инкремент
++count;//префиксный инкремент
count++;//постфиксный инкремент

x = 10;
y = ++x; // в переменную y будет записано 11
---но
x = 10;
y = x++; // в переменную y будет записано 10
^^
----------
^^68.
|*---JAVA---|*Знакомство с Java|*Что такое зарезервированные слова в Java|*
Зарезервированные слова в Java
abstract assert boolean break byte case
catch char class const continue default
do double else enum extends final
finally float for goto if implements
import instanceof int interface long native
new package private protected puЫic return
short static strictfp super switch synchronized
this throw throws transient try void
volatile while

Их нельзя использовать для именования собственных переменных
^^
----------
^^69.
|*---JAVA---|*Данные и их типы|*Дайте описание типу boolean в Java|*

Тип Описание                                                    Разрядность     Значение
boolean Представляет логические значения true и false

-----переменные типа boolean (логический тип)-------------
принимает либо true либо false
boolean b = true;
if b System.out.println("данная инструкция выполняется");
b = false;
if b System.out.println("данная инструкция не выполняется");
System.out.println("результат выполнения выражения 10>9 равен " + (10>9));
// результат выполнения выражения 10>9 равен true
^^
----------
^^70.
|*---JAVA---|*Данные и их типы|*Дайте описание типу byte в Java|*

Тип Описание                                                    Разрядность     Значение
byte 8-разрядное целое число     				8		от -128 до 127
^^
----------
^^71.
|*---JAVA---|*Данные и их типы|*Дайте описание типу char|*

Тип Описание                                                    Разрядность     Значение
char Символ, объявляется в одинарных кавычках			16		от 0 до 65536 (беззнаковое)
к переменным типа char применимы арифметические операции
^^
----------
^^72.
|*---JAVA---|*Данные и их типы|*Дайте описание типу double в Java|*

Тип Описание                                                    Разрядность     Значение
double Числовое значение с плавающей точкой двойной точности        64
^^
----------
^^73.
|*---JAVA---|*Данные и их типы|*Дайте описание типу float в Java|*

Тип Описание                                                    Разрядность     Значение
float Числовое значение с плавающей точкой одинарной точности       32
^^
----------
^^74.
|*---JAVA---|*Данные и их типы|*Дайте описание типу int в Java|*

Тип Описание                                                    Разрядность     Значение
int Целое число                                                     32          ОТ -2, 147,483,648 ДО 2, 147,483,647
^^
----------
^^75.
|*---JAVA---|*Данные и их типы|*Дайте описание типу long в Java|*

Тип Описание                                                    Разрядность     Значение
long Длинное целое число                                            64          ОТ -9,223,372,036,854,775,808 ДО 9,223,372,036,854,775,807
^^
----------
^^76.
|*---JAVA---|*Данные и их типы|*Дайте описание типу short в Java|*

Тип Описание                                                    Разрядность     Значение
short Короткое число                                                16          ОТ -32,768 ДО 32,767
^^
----------
^^77.
|*---JAVA---|*Знакомство с Java|*какая кодировка применяется в Java|*
в Java используется кодировка Unicode (с значениями от 0 до 65536) вместо кодировки ASCII с значениями от 0 до 127
^^
----------
^^78.
|*---JAVA---|*Данные и их типы|*Что такое литералы и где они применяются|*
--------литералы---------
литералы применяются для представления постоянных значений в форме,
удобной для восприятия. Литералы часто называют константами.
100, -10  целочисленный литерал
12.53 литерал типа double (эквивалент 12.53D)
13.36F литерал типа float
переменной типа long можно присваивать любые целочисленные литералы
шестнадцатиричные литералы записываются с использованием цифр от 0 до 9 и букв от A до F, число 10 соотв. числу 16 в
десятиричной системе
восьмиричные литералы записываются с использованием цифр от 0 до 7, число 10 равно 8 в десятиричной системе
hex = OxFF; // соответствует десятичному числу 255
oct = 011; // соответствует десятичному числу 9
int var1 = 0b1100   //целочисленный литерал в двоичной форме, в данном случае 12
^^
----------
^^79.
|*---JAVA---|*Работа со строками|*Что такое управляющие последовательности|*
---------управляющие последовательности-----------
\' - одинарная кавычка
\" - двойная кавычка
\\ - обратный слэш
\r - возврат каретки
\n - перенос строки
\f - Перевод страницы
\t - Горизонтальная табуляция
\Ь - Возврат но одну позицию
\ddd - Восьмеричная константа (rде ddd -восьмеричное число)
\uxxxx - Шестнадцатеричная константа (rде хххх -шестнадцатеричное число)
ch = '\t'; //присваивание переменной ch знака табуляции
ch = '\''; //присваивание переменной ch знака одинарной кавычки
^^
----------
^^80.
|*---JAVA---|*Данные и их типы|*Какие условия должны соблюдаться при неявном преобразовании типов|*
1. Неявное(расширяющее) преобразование, допустимо когда выполняются 2 условия:
- оба типа данных совместимы;
- тип к которому приводят более широкий, чем тот, который приводят
byte -> short -> int -> long -> double
int a = 5;
double = a // корректное выражение
^^
----------
^^81.
|*---JAVA---|*Данные и их типы|*Что такое явное преобразование типов, приведите пример|*
Явное преобразование типа
(целевой тип)приводимое_выражение
double x,y;
int c = (int)(x/y);

^^
----------
^^82.
|*---JAVA---|*Ввод и вывод данных|*Какие осуществляется ввод данных в консоль через System.in.read()|*
----ввод данных с клавиатуры---------
осуществляется с помощью конструкции System.in.read(), при этом необходимо осуществить явное приведение к нужному типу
например к типу char
char ch;
ch = (char)System.in.read();
при этом включается конструкция на обработку исключений, защищающая от ошибочного ввода
throws java.io.IOException {
}
^^
----------
^^83.
|*---JAVA---|*Операторы ветвления|*Как работают вложенные условия|*
Вложенные условия

if(i == 10) {
    if(j < 20) а = Ь;
    if(k > 100) с = d;
    else а = с; // этот оператор else относится
                // к оператору if(k > 100)
    }
else а = d; // а этот оператор else относится
            // к оператору if(i == 10)
^^
----------
^^84.
|*---JAVA---|*Операторы ветвления|*Опишите синтаксис конструкции if - else if - else|*
-----многоступенчатая конструкция if - else - if--------
if (условие)   // если не выполняется ни одно из условий, то выполняютя операторы блока else
    оператор;
else if (условие)
    оператор;
else if (условие)
    оператор;
    .
    .
    .
else
    оператор;
^^
----------
^^85.
|*---JAVA---|*Массивы|*Какая частая ошибка при работе с массивами|*
//Array index Out Of Bounds Exception - частая ошибка, возникающая при выходе за пределы массива (попытке обратиться
к несуществующему элементу массива
^^
----------
^^86.
|*---JAVA---|*Класс String|*Что такое имутабельность объектов класса String|*
Объекты класса String неизменяемы (имутабельны)
Классы StringBuffer, StringBuilder допускают изменение в строке
^^
----------
^^87.
|*---JAVA---|*Класс String|*Как осуществляется инициализация строки|*
Инициализация строки
String str = "Кот звучит гордо, а если натсупать на хвост ещё и громко";
^^
----------
^^88.
|*---JAVA---|*Класс String|*Как создать массив строк|*
Создание массива строк
String[] cats = {"Васька", "Мурзик", "Барсик"};
^^
----------
^^89.
|*---JAVA---|*Класс String|*Как создать пустой объект типа String|*
Создание пустого объекта типа String
String str1 = new String();//будет присвоено значение null
^^
----------
^^90.
|*---JAVA---|*Класс String|*Как создать строку через массив символов|*
Создание строки через массив символов.
char[] chars = {'H', 'e', 'l', 'l', 'o'};
String str2 = new String(chars);
^^
----------
^^91.
|*---JAVA---|*Класс String|*Как создать строку из определенного количества символов массива|*
Можно задать диапазон символьного массива для создания строки
char[] chars = {'H', 'e', 'l', 'l', 'o'};
String str3 = new String(chars,0,3);
// Hel //вторая граница диапазона не включается
^^
----------
^^92.
|*---JAVA---|*Класс String|*Как создать объект типа String из StringBuffer или StringBuilder  |*
String(StringBuffer объект_StrBuf)
String(StringBuilder объект_StrBuild)
^^
----------
^^93.
|*---JAVA---|*Класс String|*Докажите, что Все методы класса String не оперируют на исходных строках, а возвращают результатом новую строку с уже реализованным на старой строке методом |*
String s = "Hello";
s.toUpperCase();
System.out.println(s) //результатом будет также слово Hello
s = s.toUpperCase();
System.out.println(s); // теперь результатом будет HELLO, так как s ьеперь ссылается не на Hello а на строку, полученную
в резулььтате метода s.toUpperCase();
^^
----------
^^94.
|*---JAVA---|*Класс String|*В чём преимущество объектов класса StringBuilder на типом String|*
 ----Объекты класса StringBuilder----используются тогда, когда приходится делать многократно конкатенацию, что сопровождается
замеделением программы, выделением лишней памяти и созданием лишних строковых объектов
Находятся в пакете java.lang и не требуют импортирование в код программы
Являются мутабельными(изменяемыми), в отличие от объектов класса String
^^
----------
^^95.
|*---JAVA---|*Класс StringBuilder|*Создайте объект класса StringBuilder на основании строки|*
StringBuilder sb = new StringBuilder("Hello"); //создали экземпляр класса StringBuilder и прописали в его конструктор
                                               //значение, по умолчанию оно было бы равно null
^^
----------
^^96.
|*---JAVA---|*Класс StringBuilder|*Превратите объект класса StringBuilder в тип String и выведите в консоль|*
StringBuilder sb = new StringBuilder("Hello");
System.out.println(sb.toString()); //превращает объект типа StringBuilder в строку и позволяет вывести в консоль
^^
----------
^^97.
|*---JAVA---|*Класс StringBuilder|*С помощью какого метода можно добавить строку к объекту StringBuilder |*
StringBuilder sb = new StringBuilder("Hello");
sb.append(" my"); //позволяет дописать в объект значение и сохранить в нём же
sb.append(" friend");
sb.append(" my").append(" my friend"); // эквивалент двум предыдущим строчкам
System.out.println(sb.toString());


^^
----------
^^98.
|*---JAVA---|*Класс String|*Как вернуть из строки символ по указанному индексу|*
String str = "Hello";
char ch = str.charAt(0);//возвращает символ по указанному номеру из строки
System.out.println(ch);
^^
----------
^^99.
|*---JAVA---|*Класс String|*Как вернуть порядковый номер из таблицы Unicode символа строки|*
int unicode_number = str4.codePointAt(1);//возвращает порядковый номер в таблице Unicode первого символа строки
^^
----------
^^100.
|*---JAVA---|*Класс String|*Опишите принцип работы метода compareTo класса String|*
String s1 = new String("Java");
    String s2 = "JAVA";
    int result = s1.compareTo(s2); //сравнивает две строки и возвращает 0 если они одинаковые, либо возвращает
                                   // разницу в символах в виде целого числа, при сравнении учитывается регистр букв
^^
----------
^^101.
|*---JAVA---|*Класс String|*Как сравнить две строки, независимо от регистра букв|*
String s1 = new String("Java");
String s2 = "JAVA";
int result1 = s1.compareToIgnoreCase(s2);// сравнивает две строки независимо от регистров букв
^^
----------
^^102.
|*---JAVA---|*Класс String|*Опишите метод, позволяющий сложить две строки|*
String s1 = new String("Java");
String s2 = "JAVA";
String result2 = s1.concat(s2); // конкатенация строк, эквивалент s1 + s2
System.out.println(result2);
^^
----------
^^103.
|*---JAVA---|*Класс String|*Как работает метод equals класса String|*
String s1 = new String("Java");
String s2 = "JAVA";
boolean result3 = s1.equals(s2); //выдает результат сравнения строки с другим объектом (булевое)
System.out.println(result3);
boolean result4 = s1.equalsIgnoreCase(s2); // сравгивает строку с другим объектом без учёта регистра
^^
----------
^^104.
|*---JAVA---|*Класс String|*Как узнать hash-код объекта класса String|*
System.out.println(s1.hashCode()); //возвращает хэшкод строки
^^
----------
^^105.
|*---JAVA---|*Класс String|*Как узнать имеется ли сивол таблицы Unicode в строке|*
System.out.println(s1.indexOf(65)); //принимает значение в кодировке unicode символа и если он есть в строке то
                                        // то выдает номер индекса, по которому он находится
^^
----------
^^106.
|*---JAVA---|*Класс String|*Как проверить строку на пустоту|*
String s1 = "Hello";
System.out.println(s1.isEmpty()); // если длина строки равна нулю то выдает true, если нет то false
^^
----------
^^107.
|*---JAVA---|*Класс String|*Как узнать длину строки|*
int result5 = s1.length(); // возвращает длину строки - количество символов в строке, учитывая пробелы
^^
----------
^^108.
|*---JAVA---|*Класс String|*Как разбить строку на массив строк по определенному разделителю|*
String s1 = "ВасяvПетя";
String[] strings = s1.split("v");//разбивает строку на массив строк по определенному разделителю
//разобьет на массив {"Вася","Петя"}
^^
----------
^^109.
|*---JAVA---|*Класс String|*Как вернуть часть строки из всей строки|*
String value3 = "Hello World";
System.out.println(value3.substring(2,7));//возвращает строку со 2 по 7 не включительно символ
^^
----------
^^110.
|*---JAVA---|*Класс String|*Как преобразовать строку в массив символов|*
String value3 = "Hello World";
char[] chars1 = value3.toCharArray(); //преобразует строку в массив символов
for (char element:chars1) {
   System.out.println(element);
   }
^^
----------
^^111.
|*---JAVA---|*Класс String|*Как преобразовать строку в верхний или нижний регистр|*
s1 = s1.toUpperCase();//приводит к верхнему регистру
s2 = s1.toLowerCase();//приводит к нижнему регистру
^^
----------
^^112.
|*---JAVA---|*Класс String|*Как обрезать пробелы в начале и конце строки|*
String result6 = value3.trim(); // обрезает пробелы в начале и в конце строки
^^
----------
^^113.
|*---JAVA---|*Класс String|*С помощью какого метода привести к строке целочисленное значение|*
String result7 = String.valueOf(65); // приведение к строке целочисленного значения;
^^
----------
^^114.
|*---JAVA---|*Класс StringBuilder|*Какие виды конструкторов объектов StringBuilder существуют|*
Конструкторы класса StringBuilder:
StringBuilder str1 = new StringBuilder() //конструктор без параметров, резервирует память под 16 символов
StringBuilder str1 = new StringBuilder(int size) // конструктор с резервированием буфера под определенное количество символов
StringBuilder str1 = new StringBuilder("Hello"); //создание экземпляра класса и передача ему строки Hello
^^
----------
^^115.
|*---JAVA---|*Класс StringBuilder|*Создайте объект класса StringBuilder, выведите его в консоль, а также длину и размер зарезервированной памяти|*
StringBuilder str1 = new StringBuilder("Hello"); //создание экземпляра класса и передача ему строки Hello
System.out.println("String= "+str1); //Вывод в консоль объекта класса StringBuilder
System.out.println(("Lenght= "+str1.length())); // длина (количество символов объекта класса StringBuilder)
System.out.println(("Буфер= "+ str1.capacity())); // размер буфера (зарезервированное количество символов + длина)
^^
----------
^^116.
|*---JAVA---|*Класс StringBuilder|*С помощью какого метода класса StringBuilder можно вернуть указанный символ|*
---Метод CharAt-----
char ch = str1.charAt(1); //возвращает символ из строки, значащийся под указанным индексом
^^
----------
^^117.
|*---JAVA---|*Класс StringBuilder|*С помощью какого метода класса StringBuilder можно поменять значение символа по указанному индексу|*
---метод setCharAT---
str1.setCharAt(1,'o'); // заменяет символ объекта под значением 1 на 'o'
^^
----------
^^118.
|*---JAVA---|*Класс StringBuilder|*С помощью какого метода класса StringBuilder можно установить конкретную длину объекта|*
---метод setLenght---
str1.setLength(3); //устанавливает длину объекта класса StringBuilder (обрезает исходный объект)
^^
----------
^^119.
|*---JAVA---|*Класс StringBuilder|*С помощью какого метода класса StringBuilder можно вставить строку|*
------метод insert--------
StringBuilder str2 = new StringBuilder("I Java");
str2.insert(2, "like "); // добавляет начиная со 2-го индекса в объект str1 строку like
^^
----------
^^120.
|*---JAVA---|*Класс StringBuilder|*С помощью какого метода класса StringBuilder можно перевернуть строку|*
-----метод reverse-----
str2.reverse(); // переворачивает строку
^^
----------
^^121.
|*---JAVA---|*Класс StringBuilder|*С помощью какого метода класса StringBuilder можно удалить символы|*
-----методы delete, deleteCharAt-----
str2.delete(4,9); // удалит из строки символы, начиная с 4 и заканчивая 9 не включая
str2.deleteCharAt(1); // удалит из строки символ под индексом 1
^^
----------
^^122.
|*---JAVA---|*Класс StringBuilder|*С помощью какого метода класса StringBuilder можно заменить одни символы на другие|*
-----метод replace-----
StringBuilder str3 = new StringBuilder("я пошёл в магазин");
str3.replace(2,7, "поехал"); // заменяет символы с 2 по 7 не включая на указанную строку
System.out.println(str3);
^^
----------
^^123.
|*---JAVA---|*Коллекции Java|*Опишите иерархию интерфейса Collection|*
				<<Interface>> Collection
					    |
		----------------------------------------------------------
	        |			    |				  |
      <<Interface>> Set	           <<Interface>> List        <<Interface>> Queue
	(множества)			(Cписки)			   (очереди)
- HashSet			- ArrayList			- LinkedList
- LinkedHashSet			- Vector			- PriorityQueue
- TreeSet---->SortedSet		- LinkedList
^^
----------
^^124.
|*---JAVA---|*Коллекции Java|*Опишите <<Interface>> Set |*
 абор (Set) – это коллекция, которая, по определению, содержит только уникальные элементы – в ней отсутствуют дубликаты объектов. Если List может содержать одни и те же объекты многократно,
то Set может содержать данный объект только один раз. Java коллекция Set может содержать только объекты и строго регламентирует их
поведение. Поскольку Set является интерфейсом, нельзя создать его экземпляр непосредственно, необходимо использовать одну из реализаций интерфейса Set: HashSet, LinkedHashSet или TreeSet.

^^
----------
^^125.
|*---JAVA---|*Коллекции Java|*Опишите <<Interface>> List|*
List - упорядоченная коллекция списка, содержащего дубликаты
^^
----------
^^125.
|*---JAVA---|*Коллекции Java|*Опишите <<Interface>> Queue|*
Queue - обычно коллекция очереди FIFO (первым пришел -
первым обслужись - first-in, first-out), которая моделирует обслуживание в типичной очереди - каждый новый элемент добавляется в конец очереди, и элементы извлекаются с начала
очереди.
^^
----------
^^126.
|*---JAVA---|*Коллекции Java|*Опишите иерархию интерфейса Map|*
<<Interface>> Map:
- Hashtable;
- LinkedHashMap;
- HashMap;
- TreeMap---><<Interface>> SortedMap
^^
----------
^^127.
|*---JAVA---|*Коллекции Java|*Опишите <<Interface>> Map|*
Map - представляет собой связанный список, который связывает
ключи (обычно строковое значение) с объектами и не может содержать
дубликаты ключей
^^
----------
^^128.
|*---JAVA---|*Коллекции Java - <<Interface>> List|*Опишите общие понятия списков List|*
1. List - коллекция, последовательность, может содержать только объекты и строго регламентирует их поведение
2. List – не является классом в привычном понимании (это интерфейс), поэтому его экземпляр нельзя создать непосредственно
^^
----------
^^129.
|*---JAVA---|*Коллекции Java|* Чем отличается понятие <<Interface>> от понятие Class и как это реализовано в коллекциях|*
Интерфейсы (такие как List, Set, Map, Queue) не являются классами, поэтому нельзя создать их экземпляру непосредственно,
вместе с тем они описывают поведение, которое должны описать классы, использующие эти интерфейсы
То есть допустим экземпляр класса ArrayList должен реализовать все методы, определённые в интерфейсе List
^^
----------
^^130.
|*---JAVA---|*Коллекции Java - <<Interface>> List|* Объявите экземпляр класса ArrayList через супер-класс(интерфейс) List|*
List<Object> listOfObjects = new ArrayList<Object>();
^^
----------
^^131.
|*---JAVA---|*Коллекции Java - <<Interface>> List|* На что указывает обобщение <Object> в записи List<Object>|*
<Object> - это формальный тип, который указывает компилятору на то, что список List содержит коллекцию типа Object, то есть
в данном описании в List можно помещать любой объект, поскольку любой объект является потомком объекта <Object>
^^
----------
^^132.
|*---JAVA---|*Коллекции Java - <<Interface>> List|* Создайте список экземпляров класса Person|*
List<Person> listOfPersons = new ArrayList<Person>();
Здесь список List может содержать только экземпляры (объекты) класса Person, и компилятор не допустит добавления в список
объекта, отличного от типа Person
^^
----------
^^133.
|*---JAVA---|*Коллекции Java - <<Interface>> List|* Создайте список объектов <Integer> и добавьте в него элеемент в конец и в начало списка|*
List<Integer> newList = new ArrayList<Integer>();
newList.add(Integer.valueOf(234));// добавляем в конец списка целое число через класс-обёртку, поскольку нельзя добавлять примитивные типы данных
newList.add(0,Integer.valueOf(23)); //добавили целочисленный объект по указанному индексу, если указать индекс на единицу больше чем размер списка, то добавление произойдёт в конец списка
//если больше чем на единицу(несуществующий индекс) то выскочит исключение - ошибка нарушения индекса Index Out Of Bounds Exception.
^^
----------
^^134.
|*---JAVA---|*Коллекции Java - <<Interface>> List|* Создайте список объектов <Integer>, добавьте в него несколько элементов и узнайте размер списка|*
List<Object> newList = new ArrayList<Object>();
newList.add("Вася").add(Integer.valueOf(234)).add(Character.valueOf('+'));
int size = newList.size; //переменной size присвоено значение равное размеру списка через метод <имя_списка>.size
^^
----------
^^135.
|*---JAVA---|*Коллекции Java - <<Interface>> List|* Создайте список объектов <Integer>, добавьте в него несколько элементов и извлеките 1 элемент списка|*
List<Object> newList = new ArrayList<Object>();
newList.add("Вася").add(Integer.valueOf(234)).add(Character.valueOf('+'));
newList.get(1); //вернёт объект под индексом 1 из списка
^^
----------
^^136.
|*---JAVA---|*Коллекции Java - интерфейс Iterable|*В каком случае коллекция является перебираемой|*
Все коллекции Java реализуют интерфейс Collection, который в свою очередь расширяет интерфейс Iterable.
Если коллекция реализует интерфейс Iterable, то она называется перебираемой коллекцией, это означает, что можно
по порядку последовательно обращаться ко всем элементам коллекции
^^
----------
^^137.
|*---JAVA---|*Коллекции Java - интерфейс Iterable|*Что такое итератор|*
Итератор (iterator()) - Это метод, который является конструктором объекта типа Iterator
List<Integer> newList = new ArrayList<>();
Iterator iterator = newList.iterator();//в дальнейшем позволяет перебирать последовательно элементы листа через итератор
^^
----------
^^138.
|*---JAVA---|*Коллекции Java - интерфейс Iterable|*Создайте коллекцию, выведите её в консоль через итератор|*
ArrayList<String> stringList = new ArrayList<>();
stringList.add("Вася").add("Петя").add("Дима");
Iterator iterator = stringList.iterator();
while(iterator.hasNext()){
	System.out.println(iterator.next());
}
^^
----------
^^139.
|*---JAVA---|*Коллекции Java - интерфейс Iterable|*Создайте коллекцию, выведите её в консоль через цикл for in|*
ArrayList<String> stringList = new ArrayList<>();
stringList.add("Вася").add("Петя").add("Дима");
for(String name: stringList){
	System.out.println(name);
}
^^
----------
^^140.
|*---JAVA---|*Коллекции Java - интерфейс Iterable|*Опишите работу метода hasNext() итератора|*
boolean hasNext() - метод возвращает true, если в
коллекции ещё остались элементы и false, если достигнут
конец коллекции.
^^
----------
^^141.
|*---JAVA---|*Коллекции Java - интерфейс Iterable|*Опишите работу метода next() итератора|*
<объект типа коллекции> next() - метод возвращает текущий элемент. Поскольку итератор настраивается на
работу с объектами определенных классов, то этот метод
нам будет возвращает не Object, а сразу тот тип, который
содержится в списке.
^^
----------
^^142.
|*---JAVA---|*Коллекции Java - интерфейс Iterable|*Опишите работу метода remove() итератора|*
void remove()- метод удаляет из коллекции последний возвращенный итератором элемент. Этот метод может
быть вызван только однократно на один вызов next().
^^
----------
^^143.
|*---JAVA---|*Коллекции Java - интерфейс Iterable|*Создайте коллекцию типа <Integer> и удалите элемент из нее если он делится на 2|*
List<Integer> listInt = new ArrayList<>();
listInt.add(Integer.valueOf(15)).add(Integer.valueOf(20)).add(Integer.valueOf(19));
Iterator iter = listInt.iterator();
while(iter.hasNext()){
	if(iter.next()//2==0){
		iter.remove()
	}
}
^^
----------
^^144.
|*---JAVA---|*Java - Классы|*Создайте класс Olympics в нем метод main(), добавьте список видов спорта, выведите в консоль размер этого списка и сами виды спорта|*
import java.util.*;
public class Olympics {
	public static void main(String[] args) {
		// Несколько олимпийских видов спорта
		// предополагается хранить в классе ArrayList
		ArrayList<String> olympicSports = new ArrayList<String>();
		// метод add для добавления в список olympicSports
		olympicSports.add("Стрельба из лука");
		olympicSports.add(0,"Бокс");
		olympicSports.add(0,"Крикет");
		olympicSports.add(0,"Прыжки в воду");
		// Несколько олимпийских видов спорта
		System.out.println("В списке представлены " + olympicSports.size() + " олиспийских видов спорта:");
		// Организация перебора и вывода элементов списка
		for (String sport: olympicSports) {
			System.out.println(sport);
			}
		}
	}
Результат выполнения программы:
В списке представлке 4 олиспийских видов спорта:
Прыжки в воду
Крикет
Бокс
Стрельба из лука
^^
----------
^^145.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Как хранятся элементы в коллекции HashSet, по какому принципу извлекаются. Создайте и выведите в консоль экземпляр множества HashSet|*
HashSet хранит элементы в случайном (на первый взгляд) порядке. Однако элементы внутри набора HashSet упорядочены в соответствии со значением hashCode, которое рассчитывается для каждого элемента. По значению hashCode
также осуществляется поиск элемента в наборе.
HashSet<String> fruits = new HashSet<>();
        fruits.add("apple");
        fruits.add("orange");
        fruits.add("banana");
        fruits.add("banana"); //добавление уже имеющегося элемента не пройдёт
        for (String fruit:fruits) {
            System.out.println(fruit);
        }
результат:
orange
banana
apple
^^
----------
^^146.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Как хранятся элементы в коллекции TreeSet.Создайте экземпляр множества TreeSet, заполните его 20 случайными числами и выведите в консоль|*
TreeSet, в отличие от HashSet, хранит элементы упорядоченно, то есть в какой бы последовательности не добавлялись и не удалялись элементы, коллекция останется строго упорядоченной
TreeSet<Integer> numbers = new TreeSet<>();
        Random rnd = new Random();
        for(int i=0;i<20;i++){
            numbers.add(rnd.nextInt(50));
        }
        for (Integer num:numbers) {
            System.out.print(num+" ");
        }
//результат:
4 8 9 12 15 19 20 22 23 25 27 29 34 37 46 47 49 //видно,что повторяющиеся элементы не добавились
^^
----------
^^147.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Какие особенности хранения элементов в коллекции LinkedHashSet|*
LinkedHashSet используется в том случае, если необходимо помнить порядок добавления элементов. Поиск по этой коллекции происходит также по значению hashCode, но порядок будет всегда совпадать с очерёдностью добавления.
Пример:
LinkedHashSet<String> fruits = new LinkedHashSet<>();
        fruits.add("apple");
        fruits.add("orange");
        fruits.add("banana");
        fruits.add("banana");
        fruits.add("ananas");
        for (String fruit:fruits) {
            System.out.print(fruit+" ");
        }
результат:
apple orange banana ananas //в консоль вывелись элементы в порядке их добавления в множество
^^
----------
^^148.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Как работает метод add() для интерфейса Set|*
boolean add([index,] variable) - позволяет поместить некоторый объект variable в набор Set; Возвращает true, если набор не содержит элемент. Можно указать порядковый номер элемента в наборе в переменной index;

Пример:
LinkedHashSet<String> fruits = new LinkedHashSet<>();
        fruits.add("apple");
        fruits.add("orange");
        fruits.add("banana");
        fruits.add("banana");
        fruits.add("ananas");
        for (String fruit:fruits) {
            System.out.print(fruit+" ");
        }
результат:
apple orange banana ananas
^^
----------
^^149.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Что показывает метод size() интерфейса Set|*
int size() - возвращает целое, указывающее какой размер списка Set в текущий момент;
Пример:
	LinkedHashSet<String> fruits = new LinkedHashSet<>();
        fruits.add("apple");
        fruits.add("orange");
        fruits.add("banana");
        fruits.add("banana");
        fruits.add("ananas");
        int size = fruits.size();
        System.out.println("множество содержит "+size+" элемента");
Результат:
множество содержит 4 элемента
^^
----------
^^150.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Как в имеющееся множество добавить элементы другой коллекции|*
addAll(Collection c) - добавляет все элементы коллекции с (если их ещё нет)
Пример:
LinkedHashSet<String> fruits = new LinkedHashSet<>();
        fruits.add("apple");
        fruits.add("orange");
        fruits.add("banana");
        fruits.add("banana");
        fruits.add("ananas");
        int size = fruits.size();
        LinkedHashSet<String> newFruits = new LinkedHashSet<>();
        newFruits.add("orange");
        newFruits.add("strawberry");
        newFruits.add("kiwi");
        fruits.addAll(newFruits);
        System.out.println("Результат после добавления в первое множество элементов второго");
        for (String fruit:fruits) {
            System.out.print(fruit+" ");
        }
результат:
Результат после добавления в первое множество элементов второго
apple orange banana ananas strawberry kiwi
^^
----------
^^151.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Как удалить все элементы из множества|*
 clear() - удаляет все элементы коллекции;
Пример:
LinkedHashSet<String> newFruits = new LinkedHashSet<>();
        newFruits.add("orange");
        newFruits.add("strawberry");
        newFruits.add("kiwi");
        fruits.addAll(newFruits);
        newFruits.clear();
        System.out.println("Количество элементов множества newFruits после применения метода clear() " +
                "равно "+newFruits.size());
Результат:
Количество элементов множества newFruits после применения метода clear() равно 0
^^
----------
^^152.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Как проверить есть ли элемент в указанной коллекции|*
boolean contains(Object o) - возвращает true, если элемент есть в коллекции;
Пример:
LinkedHashSet<String> newFruits = new LinkedHashSet<>();
        newFruits.add("orange");
        newFruits.add("strawberry");
        newFruits.add("kiwi");
        fruits.addAll(newFruits);

        System.out.println("Результат проверки элемента Kiwi в множестве  newFruits  " +
                "равно "+newFruits.contains("kiwi"));
Результат:
Результат проверки элемента Kiwi в множестве  newFruits  равно true
^^
----------
^^153.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Как проверить есть ли все элементы указанной коллекции в указанном множестве|*
boolean containsAll(Collection c) - возвращает true, если все элементы содержатся в коллекции
Пример:
 LinkedHashSet<String> newFruits = new LinkedHashSet<>();
        newFruits.add("orange");
        newFruits.add("strawberry");
        newFruits.add("kiwi");
        fruits.addAll(newFruits);

        System.out.println("Результат проверки наличия всех элементов множества newFruits в множестве fruits:  " +
                " "+fruits.containsAll(newFruits));
Результат:
Результат проверки наличия всех элементов множества newFruits в множестве fruits:   true
^^
----------
^^154.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Как проверить пустое множество или нет|*
boolean isEmpty() - возвращает true, если в коллекции нет ни одного элемента;
Пример:
LinkedHashSet<String> newFruits = new LinkedHashSet<>();
        newFruits.add("orange");
        newFruits.add("strawberry");
        newFruits.add("kiwi");
        newFruits.clear();

        System.out.println("Результат проверки на наличие элементов в newFruits :  " +
                " "+newFruits.isEmpty());
Результат:

^^
----------
^^155.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Как удалить элемент из множества|*
boolean remove(Object o) - удаляет первое вхождение указанного элемента из этого списка, если он существует. Если список не содержит элемент, он остается неизменным
Пример:
LinkedHashSet<String> newFruits = new LinkedHashSet<>();
        newFruits.add("orange");
        newFruits.add("strawberry");
        newFruits.add("kiwi");
        newFruits.remove("kiwi");

        System.out.println("Удалили из множества элемент kiwi");
        for (String fruit:newFruits) {
            System.out.print(fruit+" ");
        }
Результат:
Удалили из множества элемент kiwi
orange strawberry
^^
----------
^^156.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Как удалить элементы коллекции из имеющегося множества|*
boolean removeAll(Collection c) - удаляет из этого набора все его элементы, которые содержатся в указанном наборе. Если указанная коллекция также набор, эта
операция эффективно изменяет этот набор, так что его значение является ассиметричной разностью двух множеств
Пример:
LinkedHashSet<String> newFruits = new LinkedHashSet<>();
        newFruits.add("orange");
        newFruits.add("strawberry");
        newFruits.add("kiwi");
        fruits.removeAll(newFruits);

        System.out.println("Выполнили операцию removeAll()");
        for (String fruit:fruits) {
            System.out.print(fruit+" ");
        }
Результат:
Выполнили операцию removeAll()
apple banana ananas
^^
----------
^^157.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Как произвести объединение(пересечение) двух множеств|*
boolean retainAll(Collection c) - оставляет только элементы в этом наборе, которые содержатся в указанном наборе. Другими словами, удаляет из этого множества все элементы, которые не содержатся в указанном наборе. Если указанная коллекция также набор, эта операция
эффективно изменяет этот набор, так что его значение является пересечением двух множеств;
Пример:
LinkedHashSet<String> newFruits = new LinkedHashSet<>();
        newFruits.add("orange");
        newFruits.add("strawberry");
        newFruits.add("kiwi");
        fruits.retainAll(newFruits);

        System.out.println("Выполнили операцию retainAll()");
        for (String fruit:fruits) {
            System.out.print(fruit+" ");
        }
Результат:
Выполнили операцию retainAll()
orange
^^
----------
^^158.
|*---JAVA---|*Коллекции Java - <<Interface>> Set|*Как преобразовать множество в массив данных|*
 Object[] toArray() - возвращает массив, содержащий элементы коллекции.
^^
----------
^^159.
|*---JAVA---|*Коллекции Java - <<Interface>> List|*Опишите принцип хранения памяти и записи(чтения) элементов в структуре LinkedList|*
LinkedList //двусвязный список
недостаток - при чтении данных чтобы посмотреть конкретный элемент списка необходимо просмотреть все данные, находящиеся
до него. Например нужен 4-й элемент
0-й->1-й->2-й->3-й->(и только потом 4-й)
достоинство - при добавлении нового элемента или удалении одного из элементов просто меняются ссылки на соседние элементы
отсутствует необходимость выделять новые ресурсы в памяти
массив - напротив удобен для чтения данных, не выгоден для добавления или удаления данных
Односвязный список - структура данных, в котором имеется информация только о текущем и ссылка на следующий элемент, если
имеется информация о следующем и предыдущем элементе - двусвязный список
весь функционал, присущий для типов List также справедлив для LinkedList
LinkedList<Integer> ls = new LinkedList<>(); //
^^
----------
^^160.
|*---JAVA---|*Коллекции Java - <<Interface>> Queue|*Каковы основные принципы работы с очередями. Продемонстрируйте пример|*
Пример:
Queue<Integer> numbers = new LinkedList<>();
        int[] array = {1,2,3,4,5,6,7};
        for (int item:array) {
            numbers.add(Integer.valueOf(item)); //Добавляем в очередь поочереди элементы массива с 1 до 7
        }
        numbers.remove(); //удалим элемент из очереди, видим что удалился тот, который первый поступил
        for (Integer num:numbers) {
            System.out.print(num+" ");
        }
Результат:
2 3 4 5 6 7
^^
----------
^^161.
|*---JAVA---|*Коллекции Java - <<Interface>> Queue|*Каковы основные принципы работы с PriorityQueue. Продемонстрируйте пример|*
PriorityQueue ----приоритетные очереди-------
принцип извлечения информации (извлекаются из очереди сначала наименьшие элементы)
PriorityQueue<Integer> qu = new PriorityQueue<>();
qu.add(13).add(123).add(1).add(6);
при выводе в консоль получим:
1
6
13
123
при извлечении элементов по очереди qu.poll() получим первым извлечется 1, далее 6 и так пока очередь не станет пустой

Пример:
       PriorityQueue<Integer> numbers = new PriorityQueue<>();
        int[] array = {5,9,7,1,2,11,6};
        for (int item:array) {
            numbers.add(Integer.valueOf(item)); //Добавляем в очередь поочереди все  элементы массива
        }
        int size = 0;
        while (size!=numbers.size()){
            System.out.println(numbers.poll());

        }
Результат:
1 2 5 6 7 9 11
^^
----------
^^162.
|*---JAVA---|*Коллекции Java - <<Interface>> Queue|*Каковы основные принципы работы с Dequeue. Продемонстрируйте пример|*
Dequeue - линейная коллекция, поддерживающая добавление и извлечение с конца и начала колеекции
Stack - структура данных, работающая по принципу FILO (первым пришёл, последним обработан), в некотором смысле аналог
рекурсии
^^
----------
^^163.
|*---JAVA---|*Коллекции Java - <<Interface>> Map|*Какие виды словарей в Java бывают и какой принцип хранения данных в каждом из них|*
Map — это структура данных, которая содержит набор пар “ключ-значение”. По своей структуре данных напоминает словарь, поэтому ее часто так и называют. В то же время, Map является интерфейсом, и в стандартном jdk содержит основные реализации: Hashmap, LinkedHashMap, Hashtable, TreeMap. Самая используемая реализация — Hashmap.
^^
----------
^^164.
|*---JAVA---|*Коллекции Java - <<Interface>> Map|*Создайте новый словарь HashMap, который будет хранить пары (число,строка)|*
Map<Integer,String> map1 = new HashMap<>(); //создание нового словаря для хранения пар ключ-значение
^^
----------
^^165.
|*---JAVA---|*Коллекции Java - <<Interface>> Map|*Создайте новый словарь HashMap, который будет хранить данные о номере паспорта и ФИО человека и наполните его тремя людьми|*
Пример:
	Map<Integer,String> pasportsAndNames = new HashMap<>(); //создание нового словаря для хранения пар ключ-значение
        pasportsAndNames.put(1238576, "Иванов Иван Иванович"); //добавление в словарь пар ключ-значение
        pasportsAndNames.put(2384474, "Сидоров Сидор Сидорович");
        pasportsAndNames.put(2634384,"Пушкин Александр Сергеевич");
Результат:
{1238576=Иванов Иван Иванович, 2634384=Пушкин Александр Сергеевич, 2384474=Сидоров Сидор Сидорович}
^^
----------
^^166.
|*---JAVA---|*Коллекции Java - <<Interface>> Map|*Создайте новый словарь HashMap, который будет хранить данные о номере паспорта и ФИО человека и наполните его тремя людьми, попробуйте записать пару с уже имеющимся ключом, что произойдет|*
Произойдёт перезапись старой пары на пару ключ значение с новым значением
Пример:
	Map<Integer,String> pasportsAndNames = new HashMap<>(); //создание нового словаря для хранения пар ключ-значение
        pasportsAndNames.put(1238576, "Иванов Иван Иванович"); //добавление в словарь пар ключ-значение
        pasportsAndNames.put(2384474, "Сидоров Сидор Сидорович");
        pasportsAndNames.put(2634384,"Пушкин Александр Сергеевич");
        pasportsAndNames.put(2634384,"Михаил Юрьевич Лермонтов"); //добавленкие пары с повторяющимся ключом
        System.out.println(pasportsAndNames);
Результат до:
{1238576=Иванов Иван Иванович, 2634384=Пушкин Александр Сергеевич, 2384474=Сидоров Сидор Сидорович}
Результат после:
{1238576=Иванов Иван Иванович, 2634384=Михаил Юрьевич Лермонтов, 2384474=Сидоров Сидор Сидорович}
^^
----------
^^167.
|*---JAVA---|*Коллекции Java - <<Interface>> Map|*Создайте новый словарь HashMap, который будет хранить данные о номере паспорта и ФИО человека и наполните его тремя людьми, получите значение по одному из ключей и выведите в консоль|*
Пример:
	Map<Integer,String> pasportsAndNames = new HashMap<>(); //создание нового словаря для хранения пар ключ-значение
        pasportsAndNames.put(1238576, "Иванов Иван Иванович"); //добавление в словарь пар ключ-значение
        pasportsAndNames.put(2384474, "Сидоров Сидор Сидорович");
        pasportsAndNames.put(2634384,"Пушкин Александр Сергеевич");
        String name = pasportsAndNames.get(1238576); // получение значения по ключу
        System.out.println("значение по ключу 1238576 равно "+name);
Результат:
значение по ключу 1238576 равно Иванов Иван Иванович
^^
----------
^^168.
|*---JAVA---|*Коллекции Java - <<Interface>> Map|*Создайте новый словарь HashMap, который будет хранить данные о номере паспорта и ФИО человека и наполните его тремя людьми, удалите оду из пар ключ-значение и выведите результат в консоль|*
Пример:
Map<Integer,String> pasportsAndNames = new HashMap<>(); //создание нового словаря для хранения пар ключ-значение
        pasportsAndNames.put(1238576, "Иванов Иван Иванович"); //добавление в словарь пар ключ-значение
        pasportsAndNames.put(2384474, "Сидоров Сидор Сидорович");
        pasportsAndNames.put(2634384,"Пушкин Александр Сергеевич");
        pasportsAndNames.remove(1238576); // удаление значения по указанному ключу
        System.out.println("содержимое словаря после удаления пары данных:\n "+pasportsAndNames);
Результат:
содержимое словаря после удаления пары данных:
 {2634384=Пушкин Александр Сергеевич, 2384474=Сидоров Сидор Сидорович}
^^
----------
^^169.
|*---JAVA---|*Коллекции Java - <<Interface>> Map|*Создайте новый словарь HashMap, который будет хранить данные о номере паспорта и ФИО человека и наполните его тремя людьми, проверьте его содержимое на наличие определенного ключа и значения|*
Пример:
	Map<Integer,String> pasportsAndNames = new HashMap<>(); //создание нового словаря для хранения пар ключ-значение
        pasportsAndNames.put(1238576, "Иванов Иван Иванович"); //добавление в словарь пар ключ-значение
        pasportsAndNames.put(2384474, "Сидоров Сидор Сидорович");
        pasportsAndNames.put(2634384,"Пушкин Александр Сергеевич");
        boolean a = pasportsAndNames.containsKey(1238576);// проверка словаря на наличие ключа
        boolean b = pasportsAndNames.containsValue("Петров Пётр Петрович");// проверка словаря на наличие значения
        System.out.println(a+" "+b);
Результат:
	true false
^^
----------
^^170.
|*---JAVA---|*Коллекции Java - <<Interface>> Map|*Создайте новый словарь HashMap, который будет хранить данные о номере паспорта и ФИО человека и наполните его тремя людьми, выведите в консоль все ключи и все значения словаря|*
Пример:
  	Map<Integer,String> pasportsAndNames = new HashMap<>(); //создание нового словаря для хранения пар ключ-значение
        pasportsAndNames.put(1238576, "Иванов Иван Иванович"); //добавление в словарь пар ключ-значение
        pasportsAndNames.put(2384474, "Сидоров Сидор Сидорович");
        pasportsAndNames.put(2634384,"Пушкин Александр Сергеевич");
        Set<Integer> pasports = new HashSet<>(pasportsAndNames.keySet());// получение множества всех ключей
        ArrayList<String> names = new ArrayList<>(pasportsAndNames.values());// получение множества всех значений
        System.out.println(pasports+"\n"+names);
Результат:
[1238576, 2634384, 2384474]
[Иванов Иван Иванович, Пушкин Александр Сергеевич, Сидоров Сидор Сидорович]
^^
----------
^^171.
|*---JAVA---|*Java - Классы|*Из каких элементов состоят классы в Java. Создайте класс с полями и любым методом|*
1. В классе определены данные и код, который выполняет действия над этими данными
2. Методы и переменные, составляющие класс - члены класса или переменные экземпляра.
Пример:
public class Person {
    public String name; //поле(переменная класса)
    public int age; //поле(переменная класса)
    public void infoPerson(Person person){  //метод класса
        System.out.println(person.name+" "+person.age);
    }
^^
----------
^^172.
|*---JAVA---|*Java - Классы|*Какова общая форма определения класса.Создайте класс Животные со своими полями и методами|*

class имя_класса {
// объявление переменных экземпляра
тип переменная1;
тип переменная2;
// ...
тип переменнаяN;
// объявление методов
тип метод1 (параметры)
// тело метода
тип метод2(параметры)
// тело метода
// ...
тип методN(параметры)
// тело метода
Пример:
public class Animal {
    public int age;
    public int numberPow;
    public String countryOfResidence;
    public double weight;
    public void infoAnimal(){
        System.out.println(this.age+" "+this.numberPow+" "+this.weight);
    }
}

^^
----------
^^173.
|*---JAVA---|*Java - Классы|*Как создать новый экземпляр класса. Создайте класс Animal и его экземпляр|*
Объявление класса - это всего лишь описание типа данных, и реальный объект при этом не создается.
Создание нового экземпляра класса проводится через конструктор класса.
Пример:
public class Animal {
    public int age;
    public int numberPow;
    public String countryOfResidence;
    public double weight;
    public void infoAnimal(){
        System.out.println(this.age+" "+this.numberPow+" "+this.weight);
    }
}
-------------------------------------------------------
public class ClassExample {
    public static void main(String[] args) {

        Animal animal1 = new Animal(); //создание экземпляра класса Animal
        animal1.infoAnimal();
    }
}
^^
----------
^^173.
|*---JAVA---|*Java - Классы|*Что такое точечная нотация при работе с экземплярами классов и данными класса|*

public class Animal {
    public int age;
    public int numberPow;
    public String countryOfResidence;
    public double weight;
    public void infoAnimal(){
        System.out.println(this.age+" "+this.numberPow+" "+this.weight);
    }
}
-------------------------------------------------------
public class ClassExample {
    public static void main(String[] args) {

        Animal animal1 = new Animal(); //создание экземпляра класса Animal
        animal1.infoAnimal();//обращение к методу InfoAnimal класса
        System.out.println("Возраст животного: "+animal1.age);//обращение к полю(переменной) age экземпляра класса
    }
}

^^
----------
^^174.
|*---JAVA---|*Java - Классы|*Создайте любой класс и несколько его экземпляров, покажите, что они ссылаются на разные области памяти|*
public class Animal {
    public int age;
    public int numberPow;
    public String countryOfResidence;
    public double weight;
    public void infoAnimal(){
        System.out.println(this.age+" "+this.numberPow+" "+this.weight);
    }
}
-------------------------------------------------------
public class ClassExample {
    public static void main(String[] args) {

        Animal animal1 = new Animal(); //создание экземпляра класса Animal
        Animal animal2 = new Animal(); //создание другого экземпляра класса Animal
        System.out.println(animal1+"\n"+animal2);//подтвердим, что разные экземпляры ссылаются на разные области памяти
    }
}

Результат:
org.example.Animal@378bf509
org.example.Animal@5fd0d5ae

^^
----------
^^175.
|*---JAVA---|*Java - Классы|*Объясните, что значит динамическое выделение памяти для объектов класса и подтвердите, что экземпляры классов - объекты ссылочного типа|*

new Vehicle() - физическая копия объекта, ссылка на которую присваивается переменной
minivan типа Vehicle. То есть память для объектов всех классов в Java выделяется динамически в момент
объявления экземпляра класса (new) и ссылка присваивается переменной класса.
Vehicle minivan; // объявить ссылку на объект
minivan = new Vehicle(); // выделить память для объекта типа Vehicle

public class Car {
    public String color;
    public int numberDoor;
    public double fuel;
}
-----------------------------------------------------
public class ClassExample {
    public static void main(String[] args) {
        Car car1 = new Car(); //создание 1-го экземпляра класса
            car1.color="green";
            car1.numberDoor=4;
            car1.fuel=5.6;
        Car car2 = new Car();
            car2=car1; //теперь экземпляр car2 ссылается на тот же объект, что и car1
        System.out.println("car2 "+car2.color+" "+car2.fuel+" "+car2.numberDoor);
            //теперь поменяем поле цвет машины на red и убедимся, что значение поменялось и для car1
            car2.color="red";
        System.out.println("car1 "+car1.color+" "+car1.fuel+" "+car1.numberDoor);
    }
}
Результат:
car2 green 5.6 4
car1 red 5.6 4
^^
----------
^^176.
|*---JAVA---|*Java - Классы|*Что такое методы в классах, опищите общую сигнатуру методов: с параметрами, возвращающих значение и не возвращающих значение|*
--------описание методов---------------
1. Методы представляют собой подпрограммы, которые манипулируют данными, определенными
в классе, а во многих случаях они предоставляют доступ к этим данным
2. В качетсве названий методов нельзя исвпользовать ключевые зарезервированные слова и слово main
3.
возращаемый_тип имя_метода(список_параметров) {
// тело метода
}
4.
тип метода, не возвращающий значение обозначается void
cписок_параметров   -  последовательность разделенных запятыми параметров с указанием их имен и типов
5.
при обращении к переменным класса внутри метода не надо использовать точечную нотацию, а обращаться к переменным напрямую.
6. ----возврат из метода----
для методов типа void операция return обозначает немедленное завершение работы метода
и возвращение к вызывающей части программы.
void myMeth() {
    int i;
    for (i=O; i<lO; i++) {
        if(i == 5) return; // завершить цикл на значении 5
        System.out.println();
        }
    }
допускается несколько операторов return для разных ветвей выполнения
-----методы, возвращаемые значение------
return значение;

// Возврат дальности поездки.
int range () {
    return mpg * fuelсар;
}
int result = minivan.range();  // переменной result присваивается результат метода range, примененный к объекту
                               // экземпляру minivan класса Vehicle
7. Использование параметров
Значение, передаваемое методу, называется аргументом, тогда как переменная, получающая аргумент, называется формальным
параметром, или просто параметром

class ChkNum {
    // вернуть логическое значение true, если х содержит четное число
    boolean isEven(int х) {
        if((x%2) == О) return true;
        else return false;
        }
    }

    class ParmDemo {
        public static void main(String args[]) {
            ChkNum е = new ChkNum();
            if(e.isEven(1O)) System.out.println("1O - четное число");
            if(e.isEven(9)) System.out.println("9 - четное число");
            if(e.isEven(8)) System.out.println("8 - четное число");
            }
    }

8. Параметры в методе могут быть разных типов
int myMeth(int а, double b, float с) {

^^
----------
^^177.
|*---JAVA---|*Java - Классы|*Что такое конструктор класса, с параметрами и без параметров|*

-----Конструкторы-------
Имя конструктора совпадает с именем класса, который он инициализирует
Конструктор определяет значение переменных, инициализированных в классе.
Если конструктор не определен принудительно, то для каждого класса он собирается по умолчанию, но только
со значениями по умолчанию (для числовых значений 0, для логических false, для строковых null)
class IsValue{
    int i
}
// по умолчанию значение i равно 0
-----определение класса с конструктором с определеным значением переменной
class IsValue {
    int i;

    IsValue() {
        i = 10;
    }
}
-----определение класса с конструктором с параметрами-----
class IsValue {
    int i;

    IsValue(int x) {
        i = x;
    }
}

// теперь при созданиии нового экземпляра класса нужно указывать параметры

IsValue value = new Isvalue(15); // по умолчанию значение Isvalue.i будет равно 15
^^
----------
^^178.

|*---JAVA---|*Java - Классы|*опишите работу оператора new при создании экземпляра класса|*
---------Подробнее об операторе new---------
переменная_класса = new имя_класса(список_аргументов);
//если в классе не определен собственный конструктор, то в операторе new будет использован
конструктор, предоставляемый в Java по умолчанию.
Оператор new возвращает ссылку на вновь создаваемый объект, которую присваивает переменной классa
Если оперативной памяти не хватает для формирования нового экземпляра класса, то генерируется исключение
времени выполнения
^^
----------
^^179.

|*---JAVA---|*Java - Классы|*как осуществляется сборка мусора в Java|*
----------Сборка мусора------------
Для того, чтобы не происходило переполнение оперативной памяти, происходит периодическое её очищение так называемым
сборщиком мусора, который анализирует наличие объектов, которые больше не нужны в работе:
- подлежат удалению;
- есть необходимость освободить занимаемую ими память
При этом нельзя точно определить, когда произойдёт сборка мусора
^^
----------
^^180.

|*---JAVA---|*Java - Классы|*как работает метод-финализатор|*
-------метод-финализатор--------
Он позволяет убедиться в том, что объект можно безболезненно удалить.
// общая форма метода:
protected void finalize() {
// здесь указывается код метода завершения //следует предусмотреть действия, которые
                                             должны быть выполнены непосредственно перед удалением объекта.
}
//Ключевое слово protected - это спецификатор, предотвращающий доступ к методу
  finalize () за пределами класса

^^
----------
^^181.

|*---JAVA---|*Java - Классы|*как работает ключевое слово this. Продемонстрируйте пример|*
ключевое слово this используется, чтобы не происходило конфликта между одинаковыми именами переменных, объявленнных
допустим в теле класса и в теле метода класса
Пример:

public class Car {
    public String color;
    public int numberDoor;
    public double fuel;

    public Car(String color, int numberDoor, double fuel) { //конструктор класса
        this.color = color; // указывает, что переменная экземпляра равна переменной, объявленной в параметре конструктора
        this.numberDoor = numberDoor;
        this.fuel = fuel;
    }
}

^^
----------
^^182.

|*---JAVA---|*Java - переопределение методов equals() и hashcode()|*Для чего нужны методы equals() и hashcode() приведите пример сравнения примитивного типа и ссылочного|*
Примитивные типы сравниваются оператором сравнения "==".

//1. Создадим две переменные типа int и сравним их методом "=="
//2. Создадим две переменные типа String и сравним их методом "==" и методом equals

public class EgualsHashcodeDemonstrate {
    public static void main(String[] args) {
//1.
        int firstNumber = 5;
        int secondNumber = 6;
        System.out.println("firstNumber == secondNumber? "+ (firstNumber==secondNumber));
//2.
        String firstString = "aaa";
        String secondString = "bbb";
        System.out.println("firstString == secondString? "+(firstString==secondString));
        System.out.println("firstString.equals(secondString) "+firstString.equals(secondString));
    }
}
Результат:

firstNumber == secondNumber? false
firstString == secondString? false
firstString.equals(secondString) false

^^
----------
^^183.

|*---JAVA---|*Java - переопределение методов equals() и hashcode()|*Создайте два экземпляра произвольного класса с одинаковыми полями и сравните их по hashcode и по equals в зависимости от значения полей и ссылок на объекты|*
Даже несмотря на то, что экземпляры person1 и person2 имеют одинаковые значения полей, они ссылаются на различные области памяти в куче, поэтому результат
сравнения их хэш-кодом равен false, аналогично при сравнении их идентичности методом equals изначально сравнивается значение их хэшей, поэтому выдается результат false

	Person person1 = new Person("Иван",50.0);
        Person person2 = new Person("Иван",50.0);
        System.out.println("//3. person1.hashcode() == person2.hashcode()? "+(person1.hashCode()==person2.hashCode()));
        System.out.println(("//3. person1.equals(person2) ? "+person1.equals(person2)));
Результат:
//3. person1.hashcode() == person2.hashcode()? false
//3. person1.equals(person2) ? false

^^
----------
^^184.

|*---JAVA---|*Java - переопределение методов equals() и hashcode()|*Создайте три  экземпляра класса (два через конструктор без параметров, третьему присвойте значение первого, сравните через hashcode и equals|*

Первый и третий экземпляр будут ссылаться на один и тот же объект, то есть хэши будут равны и следовательно на первом этапе работы метода equals будет проведено сравнение по хэшам и принято решение true
	Person pers1 = new Person();
        Person pers2 = new Person();
        Person pers3 = pers1;
        System.out.println("pers1.hashcode()==pers2.hashCode() ? "+(pers1.hashCode()==pers3.hashCode()));
        System.out.println("pers1.equals(pers3) "+pers1.equals(pers3));

Результат:
pers1.hashcode()==pers2.hashCode() ? true
pers1.equals(pers3) true

^^
----------
^^185.

|*---JAVA---|*Java - переопределение методов equals() и hashcode()|*Создайте мэпу, которая в качестве ключа будет передавать объект класса Employe а в качестве значения значения - имя сотрудника и попробуйте сохранить с в HashMap словарь по одинаковым ключам два разных значения выведите мэпу в консоль, о чём это говорит|*
	Map<Employe,String> map1 = new HashMap<Employe,String>();
        map1.put(new Employe("20",500),"Игорь");
        map1.put(new Employe("20",500),"Света");
        System.out.println(map1);
Результат:
	{age: 20 salary: 500=Игорь, age: 20 salary: 500=Света}

Как видим в ловарь произошла запись двух одинаковых ключей, чего не должно происходить
^^
----------
^^185.

|*---JAVA---|*Java - переопределение методов equals() и hashcode()|*Переопределите методы equals() и hashcode() для определенного класса|*
// перепоределение метода equals() и hashcode()
//1. нажимаем Alt+Insert и выбираем переопределение методов equals() и hashcode(), добавляя необходимые поля
// теперь не получится в словарь положить две одинаковые пары ключ<объект> значения, так как с одинаковыми полями они будут иметь и одинаковые хэши
@Override
    public boolean equals(Object o) {
        if (this == o) return true; // если объекты имеют одинаковые ссылки, то они равны
        if (o == null || getClass() != o.getClass()) return false; // если сравниваемый объект равен null, либо у них
                                                                    // не соответствуют классы, то они тоже не равны
        Employe employe = (Employe) o;
        return salary == employe.salary && Objects.equals(age, employe.age); //если же ссылки не одинаковы, объект не null
                                                                // и того же типа и все поля объекта равны полям
                                                               // сравниваемого то они равны

    }

    @Override
    public int hashCode() {
        return Objects.hash(age, salary); //здесь hash-code это не ссылка на местов памяти а число, вычисляемое на
        //основе хэш функции, прооизвольным порядком, но опираясь на данные полей объекта
    }
}
^^
----------
^^186.

|*---JAVA---|*Java - переопределение методов equals() и hashcode()|*Возможно ли в классе переопределить метод equals отдельно от hashcode?|*
1.В классе необходимо переопределение сразу обоих методов - и equals и hashcode
2. Если мы переопределим метод equals, но не переопределим метод hashcode То хэш-код для двух объектов с равными полями будет разный и они попадут в разные бакеты, причём не возникнет условий для коллизии, а хэш код
так и будет вычислять на основе ссылки на экзеипляр класса
3. Если наоборот переопределить метод хэш-код а метод equals не переопределять, то у экземпляров с одинаковыми полями хэш-коды окажутся одинакомвыми, объекты попадут в один бакет, коллизия возникнет, но будет обработана не правильно, так как объекты будут сравниваться не по значениям полей а через омператор == и будут восприняты как разные
^^
----------
^^187.

|*---JAVA---|*Java - переопределение методов equals() и hashcode()|*На что нужно обращать внимание при переопределении методов equals() самостоятельно не используя автоматическую генерацию кода|*
При самостоятельном определении метода equals необходимо придерживаться следующих принципов:
-рефлективность; (если сравнивать объект с самим собой, должнать быть истина
-транзитивность; если среди трёх объектов первый равен второму, второй равен третьему, то значит первый равен третьему
-симметричность; если первый объект идентичен второму, то второй объект идентичен первому
-проверка на идентичность с null должна выдавать ложь
^^
----------
^^188.

|*---JAVA---|*Java - реализация интерфейса Comparable|*Как осуществляется сравнивание объектов собственных типов. Переопределение метода compareTo|*
При создании собственных типов, чтобы можно было в дальнейшем сортировать экземпляры данного типа, необходимо реализовать интерфейс Comparable<название класса>, при этом выбираем
при переопределении метода compareTo выбираем конкретное поле по которому будем сравнивать
результат метода compareTo:
0 если значение полей сравниваемых объектов одинаковы
-1 если значение поля указанного экземпляра меньше, чем значение соответствующего поля сравниваемого экземпляра
 1 если значение поля указанного экземпляра больше, чем значение соответствующего поля сравниваемого экземпляра
^^
----------
^^189.

|*---JAVA---|*Java - реализация интерфейса Comparable|*Создайте собственный класс с несколькими полями, сделайте Tree мэпу с тремя экземплярами класса и значением и выведите их в консоль|*

Employ user1 = new Employ("Катя",25,2500);
        Employ user2 = new Employ("Иван",32,9400);
        Map<Employ,String> map = new TreeMap<>();
        map.put(user1,"text1");
        map.put(user2,"text2");
        for (Map.Entry<Employ,String> mapentry: map.entrySet()) {
            System.out.println(mapentry);

        }
    }
-----------------------------------------------------------------------
public class Employ implements Comparable<Employ>{ //4. Обязательно используем дженерики, чтобы указать объекты
                                                   // какого типа будут сравниваться
......
@Override
    public int compareTo(Employ o) {
        if (this.age==o.age)
            return 0;
        else if(this.age<o.age)
            return -1;
        else
            return 1;
    }

Результат:
org.example.compreToExample.Employ@378bf509=text1
org.example.compreToExample.Employ@5fd0d5ae=text2
^^
----------
^^190.

|*---JAVA---|*Java - реализация интерфейса Comparator|*Чем отличается интерфейс Comparator от Comparable|*
Интерфейс компаратор реализуется через создание отдельного класса, имплементирующего его интерфейс, тогда как интерфейс
Comparable просто имплеметируется без создания отдельного класса, принцип переопределения метода интерфейса аналогичный
только осуществляется переопределение метода compare в параметрах метода указываются сравниваемые объекты, результаты сравнения
аналогичные методу compareTo (0,-1,1)
Приоритет сравнения через Comparator выше, чем через Comparable

^^191.

|*---JAVA---|*Java - реализация интерфейса Comparator|*Создайте класс с несколькими полями, реализуйте  интерфейс Comparator, создайте TreeMap в контрукторе которого укажите интерфейс компаратора и выведите в консоль|*

public class EmployComparator implements Comparator<Employ> {

    @Override
    public int compare(Employ o1, Employ o2) {
        if (o1.getSalary()==o2.getSalary()) {
            return 0;
        }
        else if (o1.getSalary()<o2.getSalary()){
        return -1;
    }
        else return 1;
}
}
--------------------------------
public class Employ implements Comparable<Employ>{ //4. Обязательно используем дженерики, чтобы указать объекты
                                                    // какого типа будут сравниваться
    private String name;
    private int age;
    private int salary;

    public Employ(String name, int age, int salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }

    public int getSalary() {
        return salary;
    }

    @Override
    public int compareTo(Employ o) {
        if (this.age==o.age)
            return 0;
        else if(this.age<o.age)
            return -1;
        else
            return 1;
    }
}
-------------------------------------
public class ExampleMain {
    public static void main(String[] args) {
//2.
        EmployComparator employComparator = new EmployComparator();
        Employ user1 = new Employ("Катя",25,9500);
        Employ user2 = new Employ("Иван",32,2400);
        Map<Employ,String> map = new TreeMap<>(employComparator);
        map.put(user1,"text1");
        map.put(user2,"text2");
        for (Map.Entry<Employ,String> mapentry: map.entrySet()) {
            System.out.println(mapentry);

        }
    }
}

Результат:
org.example.compreToExample.Employ@5fd0d5ae=text2
org.example.compreToExample.Employ@2d98a335=text1